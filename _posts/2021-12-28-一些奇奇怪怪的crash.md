---
layout:     post
title:      一些奇奇怪怪的bug
subtitle:   谈解bug技巧
date:       2021-12-28
author:     River
header-img: img/404-bg.jpg
catalog: true
tags:
    - bug
    - Android
--- 

# 前言
>最近负责移动端基础技术的工作，其中crash治理碰到几个奇怪的bug再此记录。

#### 治理背景
1.crash率超过千分之一<br>
2.非业务因素的灰度失败率居高不下。
![修修补补又一年](/img/post-bg-map.jpg)

#### 一个奇怪的native异常
1.摘要:TrichromeLibrary.apk   00 pc 0194c6aa /product/app/TrichromeLibrary/TrichromeLibrary.apk<br>
2.恶果:直接导致了灰度期间的crash超标失败

![nativecrash](/img/crash/web_native_crash1.png)<br>
![nativecrash](/img/crash/web_native_crash2.png)<br>
![nativecrash](/img/crash/web_native_crash3.png)<br>
![nativecrash](/img/crash/web_native_crash4.png)<br>
![nativecrash](/img/crash/web_native_crash5.png)<br>

```
class XXXFragment {

  // bug在这里
  override fun onPause() {
    super.onPause()
    webView.onResume()
  }
    
}
```


#### 奇怪的空指针1

1.摘要:java.lang.NullPointerException  Attempt to invoke virtual method 'int android.view.View.getVisibility()' on a null object reference at android.widget.FrameLayout.layoutChildren(FrameLayout.java:275)<br>
2.恶果:直接导致了灰度期间的crash超标失败，无业务线认领

![nativecrash](/img/crash/view_nullPoint_exception1.png)<br>
![nativecrash](/img/crash/view_nullPoint_exception2.png)<br>
![nativecrash](/img/crash/view_nullPoint_exception3.png)<br>
![nativecrash](/img/crash/view_nullPoint_exception4.png)<br>

 ```
class XXXManager {

  // bug在这里
   private fun hideDelay() {
        coroutine.launch {
            delay(DISAPPEAR_AFTER_MS)
                if(contentView != null){
                    parentView?.removeView(contentView)
                }
        }
    }
    
}
```

#### 奇怪的空指针2

1.摘要:java.lang.NullPointerException  Attempt to read from field 'int android.graphics.Rect.left' on a null object reference at io.flutter.view.AccessibilityBridge.createAccessibilityNodeInfo(Unknown Source:535)<br>
2.恶果:直接导致了灰度期间的crash超标失败，项目中flutter大量使用，长期存在导致crash率居高不下。

![nativecrash](/img/crash/flutterview_nullPoint_exception.png)<br>

 ```
 import com.idlefish.flutterboost.XFlutterView
 
class X FlutterView {

  // bug在这里
  //无障碍模式导致,直接返回null即可
  @Override
  @Nullable
   public AccessibilityNodeProvider getAccessibilityNodeProvider() {
           if (accessibilityBridge != null && accessibilityBridge.isAccessibilityEnabled()) {
                return accessibilityBridge;
            } else {
            // TODO(goderbauer): when a11y is off this should return a one-off snapshot of
            // the a11y
            // tree.
            return null;
            }

    }
    
}
```

#### 自建热修复，patch包过大极易修复失败

1.背景:基于tinker自研热修复(前后端一体集成到CI/Cd)，自测阶段下发合并几乎都是失败的<br>
2.导致结果:排查发现，即使极小的改动；两次apk做diff生成的patch包将近20M。<br>

原因是自研APM对大部分方法做了插桩，对每个方法都会生成一个方法Id;
方法Id的生成是异步随机的 <br>

 ```
private class TraceMethodAdapter extends AdviceAdapter{
    
    ...
    
    protected void onMethodEnter(){
        TraceMethod traceMethod = collectedMethodMap.get(methodName);
            if (traceMethod != null) {
                traceMethodCount.incrementAndGet();
                mv.visitLdcInsn(traceMethod.id);
                mv.visitMethodInsn(INVOKESTATIC, TraceBuildConstants.MATRIX_TRACE_CLASS, "i", "(I)V", false);

                // 插入systrace的调用
                String sectionName = methodName;
                int length = sectionName.length();
                if (length > TraceBuildConstants.MAX_SECTION_NAME_LEN) {
                    // 先去掉参数
                    int parmIndex = sectionName.indexOf('(');
                    sectionName = sectionName.substring(0, parmIndex);
                    // 如果依然更大，直接裁剪
                    length = sectionName.length();
                    if (length > TraceBuildConstants.MAX_SECTION_NAME_LEN) {
                        sectionName = sectionName.substring(length - TraceBuildConstants.MAX_SECTION_NAME_LEN);
                    }
                }
                mv.visitLdcInsn(sectionName);
                mv.visitMethodInsn(INVOKESTATIC, TraceBuildConstants.MATRIX_TRACE_SYSTRACE_CLASS, "i", "(Ljava/lang/String;)V", false);
            }
    }
}
    
    ...

}
```
 
解决思路是把上次的trace方法的给记录生成一份mapping文件，做成可配置 <br>

 
```

public class MethodTracer {

 public MethodTracer(ExecutorService executor, MappingCollector mappingCollector, Configuration config, ConcurrentHashMap<String, TraceMethod> collectedMap, ConcurrentHashMap<String, String> collectedClassExtendMap) {
        this.configuration = config;
        this.mappingCollector = mappingCollector;
        this.executor = executor;
        this.collectedClassExtendMap = collectedClassExtendMap;
        this.collectedMethodMap = collectedMap;
}
 
private MappingCollector mappingCollector;
 
private class TraceClassAdapter extends ClassVisitor {

    ...
    private boolean isNeedTrace;

        // bug在这里无障碍模式导致,直接返回null即可
        @Override
        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
            super.visit(version, access, name, signature, superName, interfaces);
            this.className = name;
            this.isActivityOrSubClass = isActivityOrSubClass(className, collectedClassExtendMap);
            this.isNeedTrace = MethodCollector.isNeedTrace(configuration, className, mappingCollector);
            if ((access & Opcodes.ACC_ABSTRACT) > 0 || (access & Opcodes.ACC_INTERFACE) > 0) {
                this.isABSClass = true;
            }

        }
        
         @Override
        public void visitEnd() {
            if (!hasWindowFocusMethod && isActivityOrSubClass && isNeedTrace) {
                insertWindowFocusChangeMethod(cv, className);
            }
            super.visitEnd();
        }
    ...
    
    }

}
```

在build.gradle的配置代码

```
trace {
       enable = true    //if you don't want to use trace canary, set false
       baseMethodMapFile = "${project.buildDir}/baseBakApk/methodMapping.txt"
       blackListFile = "${project.projectDir}/matrixTrace/blackMethodList.txt"
}
        
```
 
#### 解bug的技巧

1. 上帝喜欢笨人，心法上没有太大的技巧；坚信肯定是哪个地方代码写错了；
2. 确认一个可疑模块，然后逐行逐行的排查。
